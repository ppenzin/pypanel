#!/usr/bin/env python
"""
PyPanel v1.3 - Lightweight panel/taskbar for X11 window managers
Copyright (c) 2003-2004 Jon Gelo (ziljian@users.sourceforge.net)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""
#----------------------------------------------------------------------------
class PyPanel(object):
#----------------------------------------------------------------------------
    #---------------------------
    def __init__(self, display):
    #---------------------------
        """ Initialize and display the panel """
        self.display = display                   # Display obj
        self.screen  = display.screen()          # Screen obj
        self.root    = self.screen.root          # Display root
        self.depth   = self.screen.root_depth    # Screen depth
        self.gc      = self.root.create_gc()     # General gfx context
        self.error   = error.CatchError()        # Error Handler/Suppressor
        self.panel   = {"sections":[]}           # Panel data and layout
        self.colors  = {}                        # Alloc'd colors
        self.hidden  = 0                         # Panel hidden/minimized
        self.focus   = 0                         # Currently focused window
        
        # Misc. initializations
        ppinit(FONT)
        
        if SHOWLINES:
            self.lgc = self.root.create_gc(foreground=self.getColor(LINE_COLOR))
        
        global P_LOCATION
        if P_LOCATION:
            P_LOCATION = self.screen.height_in_pixels - P_HEIGHT
            
        global P_WIDTH
        if not P_WIDTH:
            P_WIDTH = self.screen.width_in_pixels - P_START
        
        # Setup the panel's window
        self.window = self.screen.root.create_window(P_START, P_LOCATION,
            P_WIDTH, P_HEIGHT, 0, self.depth, window_class=X.InputOutput,
            visual=X.CopyFromParent, colormap=X.CopyFromParent,
            event_mask=(X.ExposureMask|X.ButtonPressMask|X.ButtonReleaseMask))
        
        if not TRANSPARENCY:
            self.window.change_attributes(background_pixel=self.getColor(BG_COLOR))
        else:
            ppshade(self.window.id, SHADE, P_START, P_LOCATION, P_WIDTH, P_HEIGHT)
                
        # Init the panel sections
        if WORKSPACE:
            self.panel["sections"].append(WORKSPACE)
            self.panel[WORKSPACE] = Obj(id="workspace", last=0, color=self.getColor(WS_COLOR))
        if CLOCK:
            self.panel["sections"].append(CLOCK)
            self.panel[CLOCK] = Obj(id="clock", last=0, color=self.getColor(CLOCK_COLOR))
        if TASKS:
            self.panel["sections"].append(TASKS)
            self.panel[TASKS] = Obj(id="tasks", tasks={}, last=0)
        if TRAY:
            self.panel["sections"].append(TRAY)
            self.panel[TRAY] = Obj(id="tray", tasks={}, last=0, window=self.window)
            self.createTray(self.display, self.screen)
            
        self.panel["sections"].sort()
        self.panel[self.panel["sections"][-1]].last = 1

        # Init the properties and then start the event loop
        self.setProps(self.display, self.window)
        self.root.change_attributes(event_mask=(X.PropertyChangeMask)) 
        self.window.map()
        self.loop(self.display, self.root, self.window, self.ewmh, self.panel)
        
    #------------------------------
    def createTray(self, dsp, scr):
    #------------------------------
        """ Create the System Tray Selection Owner Window """
        self._OPCODE = dsp.intern_atom("_NET_SYSTEM_TRAY_OPCODE")
        manager      = dsp.intern_atom("MANAGER")
        selection    = dsp.intern_atom("_NET_SYSTEM_TRAY_S%d" % dsp.get_default_screen())
          
        # Selection owner window          
        self.selowin = scr.root.create_window(-1, -1, 1, 1, 0, self.depth)
        self.selowin.set_selection_owner(selection, X.CurrentTime)
        self.sendEvent(self.root, manager, [X.CurrentTime, selection,
            self.selowin.id], mask=(X.StructureNotifyMask))
                        
    #--------------------------------------
    def setStruts(self, win, option="set"):
    #--------------------------------------
        """ Set/Unset the panel struts """
        if option == "set":
            if P_LOCATION:
                top = top_start = top_end = 0
                bottom       = P_HEIGHT
                bottom_start = P_START
                bottom_end   = P_START + P_WIDTH
            else:
                top       = P_HEIGHT
                top_start = P_START
                top_end   = P_START + P_WIDTH
                bottom = bottom_start = bottom_end = 0
            
            win.change_property(self._STRUT, Xatom.CARDINAL, 32, [0, 0, top, bottom])
            win.change_property(self._STRUTP, Xatom.CARDINAL, 32,
                [0, 0, top, bottom, 0, 0, 0, 0, top_start, top_end,
                bottom_start, bottom_end])
        else:
            win.change_property(self._STRUT, Xatom.CARDINAL, 32, [0,0,0,0])
            win.change_property(self._STRUTP, Xatom.CARDINAL, 32, [0,0,0,0,0,0,0,0,0,0,0,0])
        
    #----------------------------
    def setProps(self, dsp, win):
    #----------------------------
        """ Set general and window manager specific properties/hints """
        win.set_wm_name("PyPanel")
        win.set_wm_class("pypanel","PyPanel")
        win.set_wm_hints(flags=Xutil.InputHint, input=0)
        win.set_wm_normal_hints(flags=(Xutil.PPosition))
        win.change_property(dsp.intern_atom("_MOTIF_WM_HINTS"),
            dsp.intern_atom("_MOTIF_WM_HINTS"), 32, [0x2, 0x0, 0x0, 0x0, 0x0])
        
        self._CHANGE_STATE    = dsp.intern_atom("WM_CHANGE_STATE")
        self._CURRENT_DESKTOP = dsp.intern_atom("_NET_CURRENT_DESKTOP")
        self._SKIP_TASKBAR    = dsp.intern_atom("_NET_WM_STATE_SKIP_TASKBAR")
        self._BELOW           = dsp.intern_atom("_NET_WM_STATE_BELOW")  
        self._ABOVE           = dsp.intern_atom("_NET_WM_STATE_ABOVE")
        self._HIDDEN          = dsp.intern_atom("_NET_WM_STATE_HIDDEN")
        self._SHADED          = dsp.intern_atom("_NET_WM_STATE_SHADED")
        self._STRUTP          = dsp.intern_atom("_NET_WM_STRUT_PARTIAL")
        self._STRUT           = dsp.intern_atom("_NET_WM_STRUT")
        self._NAME            = dsp.intern_atom("_NET_WM_NAME")
        self.openbox          = dsp.intern_atom("_OPENBOX_PID", 1)

        if not dsp.intern_atom("_WINDOWMAKER_NOTICEBOARD", 1):
            # EWMH specific hints
            self.ewmh = 1
            self._WORKSPACE_NAMES = dsp.intern_atom("_NET_DESKTOP_NAMES")             
            self._NUM_WORKSPACES  = dsp.intern_atom("_NET_NUMBER_OF_DESKTOPS")
            self._WORKSPACE       = dsp.intern_atom("_NET_WM_DESKTOP")
            self._CLIENT_LIST     = dsp.intern_atom("_NET_CLIENT_LIST")
            self._STATE           = dsp.intern_atom("_NET_WM_STATE")
            win.change_property(dsp.intern_atom("_NET_WM_WINDOW_TYPE"),
                Xatom.ATOM, 32, [dsp.intern_atom("_NET_WM_WINDOW_TYPE_DOCK")])
            win.change_property(self._WORKSPACE, Xatom.CARDINAL, 32, [0xffffffffL])
            self.setStruts(win)
        else:
            # Window Maker specific hints
            self.ewmh = 0
            self._WORKSPACE_NAMES = dsp.intern_atom("_WIN_WORKSPACE_NAMES") 
            self._NUM_WORKSPACES  = dsp.intern_atom("_WIN_WORKSPACE_COUNT")
            self._WORKSPACE       = dsp.intern_atom("_WIN_WORKSPACE")
            self._CLIENT_LIST     = dsp.intern_atom("_WIN_CLIENT_LIST")
            self._STATE           = dsp.intern_atom("_WIN_STATE")
            win.change_property(self._WORKSPACE, Xatom.CARDINAL, 16, [0])
            win.change_property(self._STATE, Xatom.CARDINAL, 16, [1])
            win.change_property(dsp.intern_atom("_WIN_LAYER"), Xatom.CARDINAL, 32, [10])
            win.change_property(dsp.intern_atom("_WIN_HINTS"), Xatom.CARDINAL, 32, [39])
            
    #-----------------------------------------------------------
    def setState(self, task, panel, draw=0, dsp=None, win=None):
    #-----------------------------------------------------------
        """ Set/Update a tasks state and add it to the task list """
        try:
            state = task.obj.get_wm_state()
            if not state:
                task.state = Xutil.NormalState
            else:
                task.state = state["state"]
        except:
            return
            
        if task.state == Xutil.IconicState:
            task.color = self.getColor(MINIMIZED_COLOR)
        elif task.id == self.focus:
            task.color = self.getColor(FOCUSED_COLOR)
        else:
            task.color = self.getColor(TASK_COLOR)
            try:
                if self.ewmh:
                    if self._SHADED in task.obj.get_full_property(self._STATE,
                        Xatom.ATOM).value:
                        task.color = self.getColor(SHADED_COLOR)
                elif task.obj.get_full_property(self._STATE,
                    Xatom.CARDINAL).value[0] == 32:
                    task.color = self.getColor(SHADED_COLOR)
            except:
                pass
        if draw:
            x = task.x1 + P_SPACER
            if APPICONS:
                ppicon(win.id, task.obj.id, x, (P_HEIGHT-I_HEIGHT)/2, I_WIDTH,
                    I_HEIGHT)
                x += I_WIDTH+P_SPACER
            win.clear_area(x, 0, task.x2 - x, P_HEIGHT)
            dsp.sync()
            ppfont(win.id, task.color, x, P_HEIGHT, task.x2-x-P_SPACER, task.name)
        panel[TASKS].tasks[task.id] = task
    
    #----------------------------
    def getWS(self, task, root=0):
    #----------------------------
        """ Return the workspace number of the given task obj """
        try:
            if self.ewmh and root:
                return task.get_full_property(self._CURRENT_DESKTOP,
                    Xatom.CARDINAL).value[0]
            return task.get_full_property(self._WORKSPACE, Xatom.CARDINAL).value[0]
        except:
            return None 
            
    #-------------------------
    def getColor(self, color):
    #-------------------------
        """ Function to get/convert/alloc a color given a single hex str """
        try:
            return self.colors[color]
        except:
            pass
            
        r = int("0x"+color[2:4],0)*257
        g = int("0x"+color[4:6],0)*257
        b = int("0x"+color[6:8],0)*257
        c = self.screen.default_colormap.alloc_color(r, g, b)
        
        if not c:
            sys.stderr.write("Error allocating color: %s\n" % color)
            return self.screen.white_pixel
        else:
            self.colors[color] = c.pixel
            return c.pixel
            
    #-----------------------
    def getName(self, task):
    #-----------------------
        """ Return the name of the given task obj """
        try:
            name = None
            if self.ewmh:
                name = task.get_full_property(self._NAME, X.AnyPropertyType)
            if not name or not self.ewmh:
                name = task.get_full_property(Xatom.WM_NAME, X.AnyPropertyType)
            if not name:
                return ""
            else:
                return name.value
        except:
            return ""
        
    #------------------------------------------------
    def sendEvent(self, win, ctype, data, mask=None):
    #------------------------------------------------
        """ Send a ClientMessage event to the root """
        data = (data+[0]*(5-len(data)))[:5]
        ev = Xlib.protocol.event.ClientMessage(window=win, client_type=ctype,
            data=(32,(data)))

        if not mask:
            mask = (X.SubstructureRedirectMask|X.SubstructureNotifyMask)
        self.root.send_event(ev, event_mask=mask)
                                             
    #------------------------------
    def changeWorkspace(self, num):
    #------------------------------
        """ Increase/Decrease the current workspace number by num """
        cur = self.getWS(self.root, 1) + num
        tot = self.root.get_full_property(self._NUM_WORKSPACES,
            X.AnyPropertyType).value[0] - 1

        if cur < 0:
            cur = tot
        elif cur > tot:
            cur = 0
            
        if self.ewmh:
            self.sendEvent(self.root, self._CURRENT_DESKTOP, [cur])
        else:
            self.sendEvent(self.root, self._WORKSPACE, [cur])
        
    #---------------------------------
    def toggleHidden(self, side=None):
    #---------------------------------
        """ Hide/Unhide the Panel """
        if self.hidden:
            self.window.configure(x=P_START, y=P_LOCATION, width=P_WIDTH)
            self.setStruts(self.window, "set")
            self.hidden = 0
            self.sendEvent(self.window, self._STATE, [0, self._BELOW])
            self.sendEvent(self.window, self._STATE, [1, self._ABOVE])
        else:
            width = 12 # Width of minimized panel
            if side == "right":
                x = self.screen.width_in_pixels - width
                self.arrow = "<"
            else:
                x = 0
                self.arrow = ">"
            
            self.hidden = 1
            self.window.clear_area()
            self.window.configure(x=x, y=P_LOCATION, width=width)
            self.display.sync()
            ppfont(self.window.id, self.getColor(LINE_COLOR), 1, P_HEIGHT, 0, self.arrow)
            self.setStruts(self.window, "unset")
            self.sendEvent(self.window, self._STATE, [1, self._BELOW])
            self.sendEvent(self.window, self._STATE, [0, self._ABOVE])
            
    #----------------------------------------
    def toggleMinimize(self, task, traise=1):
    #----------------------------------------
        """ Iconify/Deiconify a task """
        if self.ewmh and not self.openbox:
            self.sendEvent(task.obj, self._STATE, [2, self._HIDDEN])
        else:
            if task.state == Xutil.NormalState:
                self.sendEvent(task.obj, self._CHANGE_STATE, [Xutil.IconicState])
            else:
                task.obj.map()
        if traise:
            self.taskRaise(task, 0)
                
    #---------------------------
    def toggleShade(self, task):
    #---------------------------
        """ Shade/Unshade a task """
        if self.ewmh:
            self.sendEvent(task.obj, self._STATE, [2, self._SHADED])
        else:
            if task.obj.get_full_property(self._STATE, Xatom.CARDINAL).value[0] == 0:
                shade = 32
            else:
                shade = 0
            task.obj.change_property(self._STATE, Xatom.CARDINAL, 16, [shade])
            task.obj.unmap()
            task.obj.map()
            
    #-------------------------
    def taskFocus(self, task):
    #-------------------------
        """ Give focus to an unfocused task else toggle minimization """
        if task.id == self.focus or task.state == Xutil.IconicState:
            self.toggleMinimize(task)
        else:
            self.taskRaise(task, 1)
            
    #----------------------------------
    def taskRaise(self, task, focus=0):
    #----------------------------------
        """ Raise a task """
        if task.state == Xutil.NormalState:
            task.obj.configure(stack_mode=X.Above)
            if focus:
                task.obj.set_input_focus(X.RevertToNone, X.CurrentTime)
    
    #----------------------------------
    def taskLower(self, task, focus=0):
    #----------------------------------
        """ Lower a task """
        if task.state == Xutil.NormalState:
            task.obj.configure(stack_mode=X.Below)
            if focus:
                task.obj.set_input_focus(X.RevertToNone, X.CurrentTime)
                
    #-------------------------------------------------
    def updatePanel(self, dsp, root, win, cws, panel):
    #-------------------------------------------------
        """ Display the tasks, clock and workspace name on the panel """
        tasks       = panel[TASKS].tasks
        task_width  = P_WIDTH
        curr_x      = 0
        
        if CLOCK:
            panel[CLOCK].name  = time.strftime(CLOCK_FORMAT, time.localtime())
            panel[CLOCK].width = ppfontsize(panel[CLOCK].name)
            task_width -= panel[CLOCK].width + P_SPACER*2
            
        if WORKSPACE:
            try:
                panel[WORKSPACE].name = root.get_full_property(
                    self._WORKSPACE_NAMES,
                    X.AnyPropertyType).value.split("\x00")[cws]
            except:
                panel[WORKSPACE].name = str(cws)
            panel[WORKSPACE].width = ppfontsize(panel[WORKSPACE].name)
            task_width -= panel[WORKSPACE].width + P_SPACER*2
            
        if TRAY:            
            task_width -= (len(panel[TRAY].tasks)*TRAY_I_WIDTH) + P_SPACER*2

        if tasks:
            name_limit = (task_width / len(tasks)) - (P_SPACER*2)
            if APPICONS:
                name_limit -= I_WIDTH + P_SPACER
        
        # Clear the panel and add the objects
        win.clear_area()
        dsp.sync()        
        for section in panel["sections"]:
            if panel[section].id == "tasks":
                if not tasks:
                    curr_x += task_width
                else:
                    count  = 1
                    icon_y = (P_HEIGHT-I_HEIGHT)/2
                    for t in tasks.values():
                        tasks[t.id].x1 = curr_x
                        curr_x += P_SPACER
                        if APPICONS:
                            ppicon(win.id, t.obj.id, curr_x, icon_y, I_WIDTH, I_HEIGHT)
                            curr_x += I_WIDTH + P_SPACER
                        ppfont(win.id, t.color, curr_x, P_HEIGHT, name_limit, t.name)
                        curr_x += name_limit + P_SPACER
                        if count < len(tasks) and SHOWLINES:
                            win.poly_segment(self.lgc, [(curr_x, 0, curr_x, P_HEIGHT)])
                        tasks[t.id].x2 = curr_x
                        count += 1
                if SHOWLINES and not panel[section].last:
                    win.poly_segment(self.lgc, [(curr_x, 0, curr_x, P_HEIGHT)])
            elif panel[section].id == "tray":
                # System Tray
                y = (P_HEIGHT-TRAY_I_HEIGHT)/2
                curr_x += 2
                for task in panel[TRAY].tasks.values():
                    task.x = curr_x
                    task.y = y
                    task.obj.configure(x=curr_x, y=y, width=TRAY_I_WIDTH,
                         height=TRAY_I_HEIGHT, onerror=self.error)
                    dsp.sync()
                    task.obj.map(onerror=self.error)
                    curr_x += TRAY_I_WIDTH + 1
                if SHOWLINES and not panel[section].last:
                    win.poly_segment(self.lgc, [(curr_x, 0, curr_x, P_HEIGHT)])
            else:
                # Clock or Workspace
                panel[section].x1 = curr_x
                curr_x += P_SPACER
                ppfont(win.id, panel[section].color, curr_x, P_HEIGHT, 0,
                       panel[section].name)
                curr_x += panel[section].width + P_SPACER
                panel[section].x2 = curr_x
                if SHOWLINES and not panel[section].last:
                    win.poly_segment(self.lgc, [(curr_x, 0, curr_x, P_HEIGHT)])
                
    #--------------------------------------------
    def updateTasks(self, dsp, root, win, panel):
    #--------------------------------------------
        """ Update the task list for the current workspace """
        panel[TASKS].tasks = {}
        cws   = self.getWS(root, 1)
        tasks = root.get_full_property(self._CLIENT_LIST, X.AnyPropertyType)
        if tasks and tasks.value:
            try:
                self.focus = dsp.get_input_focus().focus.id
            except:
                pass
                
            for task in tasks.value:
                obj    = dsp.create_resource_object("window", task)
                obj_ws = self.getWS(obj)
                if obj_ws != None and (cws == obj_ws or obj_ws == 0xffffffffL):
                    try:
                        if self._SKIP_TASKBAR in obj.get_full_property(
                            self._STATE, X.AnyPropertyType).value: continue
                    except:
                        pass
                    try:
                        tclass = obj.get_wm_class() or ()
                        for t in tclass:
                            if t in HIDE_LIST:
                                raise
                        name = self.getName(obj)
                        if name == "PyPanel":
                            continue
                    except:
                        continue
                else:
                    continue
                    
                obj.change_attributes(event_mask=(X.PropertyChangeMask|
                    X.FocusChangeMask|X.StructureNotifyMask))
                self.setState(Obj(id=task, obj=obj, name=name, tclass=tclass,
                    x1=-1, x2=-1), panel)
        self.updatePanel(dsp, root, win, cws, panel)
        
    #---------------------------------
    def buttonRelease(self, panel, e):
    #---------------------------------
        """ Button Release event handler """
        x = e.event_x
        for section in panel["sections"]:
            if panel[section].id == "tray":
                continue
            elif panel[section].id == "workspace":
                if x > panel[section].x1 and x < panel[section].x2:
                    workSpaceButtonEvent(self, e.detail)
                    return
            elif panel[section].id == "clock":
                if x > panel[section].x1 and x < panel[section].x2:
                    clockButtonEvent(self, e.detail)
                    return
            else:
                for t in panel[TASKS].tasks.values():
                    if x > t.x1 and x < t.x2:
                        taskButtonEvent(self, e.detail, t)
    
    #-------------------------------------------
    def loop(self, dsp, root, win, ewmh, panel):
    #-------------------------------------------
        """ Event loop - handle events as they occur until we're killed """
        mapped  = 1
        rpm     = dsp.intern_atom("_XROOTPMAP_ID")
        states  = [dsp.intern_atom("WM_STATE"), self._STATE]
        props   = [self._CLIENT_LIST, self._CURRENT_DESKTOP, self._WORKSPACE]   
        
        while 1:
            if not mapped:                
                if not TRANSPARENCY:
                    win.change_attributes(background_pixel=self.getColor(BG_COLOR))
                else:
                    ppshade(win.id, SHADE, P_START, P_LOCATION, P_WIDTH, P_HEIGHT)
                win.map()
                mapped = 1
                if ewmh:
                    self.sendEvent(win, self._STATE, [2,self._HIDDEN])
                    win.change_property(self._WORKSPACE, Xatom.CARDINAL, 32, [0xffffffffL])
                                        
            while dsp.pending_events():
                e = dsp.next_event()
                if e.type == X.ButtonRelease:
                    if self.hidden:
                        self.toggleHidden()
                        self.updateTasks(dsp, root, win, panel)
                    else:
                        self.buttonRelease(panel, e)
                elif e.type == X.DestroyNotify:
                    if e.window.id in panel[TASKS].tasks:
                        del panel[TASKS].tasks[e.window.id]
                    elif TRAY and e.window.id in panel[TRAY].tasks:
                        del panel[TRAY].tasks[e.window.id]
                    if not self.hidden:
                        self.updatePanel(dsp, root, win, self.getWS(root, 1), panel)
                elif e.type == X.PropertyNotify:
                    if e.atom in props and not self.hidden:
                        self.updateTasks(dsp, root, win, panel)
                    elif e.atom == rpm and TRANSPARENCY:
                        self.sendEvent(win, self._STATE, [2, self._HIDDEN])
                        win.unmap()
                        mapped = 0                    
                    if e.window.id in panel[TASKS].tasks:
                        if e.atom in states:
                            self.setState(panel[TASKS].tasks[e.window.id], panel, 1, dsp, win)
                        elif e.atom == Xatom.WM_NAME or e.atom == self._NAME:
                            t = panel[TASKS].tasks[e.window.id]
                            name = self.getName(t.obj)
                            if t.name != name:
                                t.name = name
                                x = t.x1 + P_SPACER
                                if APPICONS:
                                    ppicon(win.id, t.obj.id, x,
                                        (P_HEIGHT-I_HEIGHT)/2, I_WIDTH, I_HEIGHT)
                                    x += I_WIDTH+P_SPACER
                                win.clear_area(x, 0, t.x2 - x, P_HEIGHT)
                                dsp.sync()
                                ppfont(win.id, t.color, x, P_HEIGHT, t.x2-x-P_SPACER, t.name)
                        elif e.atom == Xatom.WM_HINTS and APPICONS:
                            t = panel[TASKS].tasks[e.window.id]
                            x = t.x1 + P_SPACER
                            win.clear_area(x, 0, t.x2 - x, P_HEIGHT)
                            dsp.sync()
                            ppicon(win.id, t.obj.id, x,
                                (P_HEIGHT-I_HEIGHT)/2, I_WIDTH, I_HEIGHT)
                            x += I_WIDTH+P_SPACER
                            ppfont(win.id, t.color, x, P_HEIGHT, t.x2-x-P_SPACER, t.name)
                elif e.type == X.ConfigureNotify and TRAY:
                    if e.window.id in panel[TRAY].tasks:
                        task = panel[TRAY].tasks[e.window.id]
                        task.obj.configure(width=task.w, height=task.h)
                elif e.type == X.ClientMessage and TRAY:
                    if e.window == self.selowin:
                        data = e.data[1][1] # opcode
                        task = e.data[1][2] # taskid
                        if e.client_type == self._OPCODE and data == 0:
                            # SYSTEM_TRAY_REQUEST_DOCK opcode = 0
                            obj = dsp.create_resource_object("window", task)
                            obj.reparent(panel[TRAY].window.id, 0, 0)
                            obj.change_attributes(event_mask=(X.StructureNotifyMask))
                            panel[TRAY].tasks[task] = Obj(obj=obj, w=TRAY_I_WIDTH, h=TRAY_I_HEIGHT)
                elif e.type == X.FocusIn:
                    prev_focus = self.focus
                    self.focus = e.window.id
                    for id in (e.window.id, prev_focus):
                        if id in panel[TASKS].tasks:
                            self.setState(panel[TASKS].tasks[id], panel, 1, dsp, win)
                elif e.type == X.Expose and e.count == 0:
                    if self.hidden:
                        ppfont(win.id, self.getColor(LINE_COLOR), 1, P_HEIGHT, 0, self.arrow)
                    else:
                        self.sendEvent(win, self._STATE, [1, self._SKIP_TASKBAR])
                        self.sendEvent(win, self._STATE, [1, self._ABOVE])
                        self.updateTasks(dsp, root, win, panel)
                  
            rs, ws, es = select.select([dsp.display.socket], [], [], 20)
            if CLOCK and not rs and not self.hidden:
                now = time.strftime(CLOCK_FORMAT, time.localtime())
                if panel[CLOCK].name != now:
                    panel[CLOCK].name = now
                    win.clear_area(panel[CLOCK].x1+1, 0, panel[CLOCK].x2-1, P_HEIGHT)
                    dsp.sync()
                    ppfont(win.id, panel[CLOCK].color, panel[CLOCK].x1+P_SPACER, P_HEIGHT, 0, now)
                    panel[CLOCK].x2 = panel[CLOCK].x1 + ppfontsize(now) + P_SPACER

#----------------------------------------------------------------------------                

class Obj(object):
    """ Multi-purpose empty object class """
    def __init__(self, **kwargs): 
        self.__dict__.update(kwargs)

#----------------------------------------------------------------------------
#                                  Main
#----------------------------------------------------------------------------
from distutils import sysconfig
from ppmodule import ppinit, ppshade, ppicon, ppfont, ppfontsize
from Xlib import X, display, error, Xatom, Xutil
import Xlib.protocol.event
import os, pwd, select, sys, time

if __name__ == "__main__":
    try:
        home = pwd.getpwuid(os.getuid())[5]
        if os.path.isfile("/etc/pypanelrc"):
            execfile("/etc/pypanelrc")
        if not os.path.isfile("%s/.pypanelrc" % home):
            import shutil
            src = "%s/pypanel/pypanelrc" % sysconfig.get_python_lib()
            dst = "%s/.pypanelrc" % home
            shutil.copyfile(src, dst)
            del src, dst
        execfile("%s/.pypanelrc" % home)
        del home
    except StandardError, e:
        sys.stderr.write("\nFailed to open ~/.pypanelrc -\n\n")
        sys.stderr.write(str(e)+"\n\n")
        sys.exit()
    PyPanel(display.Display())
